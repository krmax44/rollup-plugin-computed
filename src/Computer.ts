import type { PluginContext } from 'rollup';

type ComputerFn = (this: PluginContext) => any | Promise<any>;

export default class Computer {
	/**
	 * The computer function.
	 */
	fn: ComputerFn;

	/**
	 * The computer's name.
	 */
	name: string;

	/**
	 * The computer function's return value needs to be serialized to an ES module.
	 * By default, it will be JSON.stringify'ed and set as the default ES export.
	 * You can disable serialization by returning a string in your compute function
	 * and setting serializer to false.
	 * You can also provide a custom serializer function.
	 * @default json
	 */
	serializer: 'json' | false | ((computerFnOutput: any) => string) = 'json';

	/**
	 * Split the computed data into a seperate chunk.
	 * @default true
	 */
	split = true;

	/**
	 * Required for assets. Without a dot.
	 */
	fileExt?: string;

	/**
	 * Output filename. Generated by rollup by default, based on the computer's name.
	 */
	fileName?: string;

	/**
	 * Rollup file type. Assets will not be serialized.
	 * @default chunk
	 */
	type: 'chunk' | 'asset' = 'chunk';

	/**
	 * Always include it during build, even if it's not imported anywhere in the app.
	 */
	alwaysBuild = false;

	cache?: any | Buffer;

	constructor(fn: ComputerFn, name: string) {
		this.fn = fn;
		this.name = name;
	}

	public async get(rollup: PluginContext): Promise<any> {
		if (this.cache) return this.cache;

		return Promise.resolve(this.fn.apply(rollup));
	}

	get id(): string {
		return `${this.name}.computed`;
	}

	public async serialize(rollup: PluginContext): Promise<any> {
		const computed = await this.get(rollup);

		if (this.serializer === 'json') {
			return `export default ${JSON.stringify(computed)};`;
		} else if (typeof this.serializer === 'function') {
			return this.serializer(computed);
		} else {
			return computed;
		}
	}

	public async emit(rollup: PluginContext): Promise<string> {
		const { id, type, fileName, name, fileExt } = this;
		const source = await this.get(rollup);

		return rollup.emitFile({
			id,
			type,
			fileName,
			source,
			name: type === 'asset' ? `${name}.${fileExt}` : name
		});
	}

	static from(input: ComputerObj, name: string): Computer {
		const computer = new Computer(input.fn, name);
		Object.assign(computer, input);
		return computer;
	}

	static normalize(raw: ComputerFn | ComputerObj, name: string): Computer {
		return typeof raw === 'function'
			? new Computer(raw, name)
			: Computer.from(raw, name);
	}
}

type OptionalExceptFor<T, TRequired extends keyof T> = Partial<T> &
	Pick<T, TRequired>;

export type ComputerObj = OptionalExceptFor<Computer, 'fn'>;
